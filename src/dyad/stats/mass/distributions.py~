__all__ = [
    "kroupa"
]

import numpy as np
import scipy as sp


class _kroupa_gen(sp.stats.rv_continuous):
    r"""The Kroupa initial stellar mass random variable

    %(before_notes)s

    Notes
    -----
    The probability density function for `kroupa` is:

    .. math::

        f(x, a, b, c) = xxx.

    where :math:`x > 0` and :math:`a < c < b` [1]_.

    `kroupa` takes :math:`a`, :math:`b`, and :math:`c` as shape parameters.

    %(after_notes)s

    References
    ----------
    .. [1] Reference

    %(example)s

    """
    def _argcheck(self, s, a, b):
        return (0. < a) & (a < b) & (a < s) & (s < b)

    def _shape_info(self):
        is_ = _ShapeInfo("s", False, (0, np.inf), (False, False))
        ia = _ShapeInfo("a", False, (0, np.inf), (False, False))
        ib = _ShapeInfo("b", False, (0, np.inf), (False, False))
        return [is_, ia, ib]
    
    def _get_support(self, s, a, b):
        return a, b

    def _pdf(self, x, s, a, b):
        def f1(x):
            return x**c

        def f2(x):
            return s**(c - d)*x**d

        c = -1.3
        d = -2.3
        A = (
            (s**(c + 1.) - a**(c + 1.))/(c + 1.)
            + s**(c - d)*(b**(d + 1.) - s**(d + 1.))/(d + 1.)
        )

        return np.where(x < s, f1(x), f2(x))/A

    def _cdf(self, x, s, a, b):
        def f1(x):
            return (x**(c + 1.) - a**(c + 1.))/(c + 1.)

        def f2(x):
            return f1(s) + s**(c - d)*(x**(d + 1.) - s**(d + 1.))/(d + 1.)

        c = -1.3
        d = -2.3
        A = (
            (s**(c + 1.) - a**(c + 1.))/(c + 1.)
            + s**(c - d)*(b**(d + 1.) - s**(d + 1.))/(d + 1.)
        )

        return np.where(x < s, f1(x), f2(x))/A
    
    def _ppf(self, q, s, a, b):
        def f1(q):
            return (A*(c + 1.)*q + a**(c + 1.))**(1./(c + 1.))

        def f2(q):
            res = (
                A*(d + 1.)*(q - self._cdf(s, s, a, b))/s**(c - d) + s**(d + 1.)
            )

            return res**(1./(d + 1.))

        c = -1.3
        d = -2.3
        A = (
            (s**(c + 1.) - a**(c + 1.))/(c + 1.)
            + s**(c - d)*(b**(d + 1.) - s**(d + 1.))/(d + 1.)
        )

        return np.where(q < self._cdf(s, s, a, b), f1(q), f2(q))

    
kroupa = _kroupa_gen(name="kroupa")
